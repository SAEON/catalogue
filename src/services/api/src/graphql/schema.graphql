# https://itnext.io/improve-your-graphql-schema-with-the-relay-specification-8952d06998eb

scalar DateTime
scalar JSON
scalar Void

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

# Interfaces

interface Node {
  id: ID!
}

interface Connection {
  # A list of edges
  edges: [Edge!]!
  # A list of nodes
  nodes: [Node!]
  # Information to aid in pagination
  pageInfo: PageInfo!
  # Count of total results
  totalCount: Int!
}

interface Edge {
  cursor: String!
  node: Node!
}

# Catalogue

type Catalogue {
  id: ID!

  # Fetch metadata records from SAEON's data catalogue
  records(
    # Fetch a single record by ID (other arguments are ignored)
    id: String
    # Search for intersection of subject list
    subjects: [String!]
    # Return the first N elements from the list
    first: Int
    # Return the last N elements from the list
    last: Int
    # Return elements in the list that come after the specified cursor
    after: ID
    # Return elements in the list that come before the specified cursor
    before: ID
  ): Connection!

  # Get count aggregation of record fields, with optional filters
  summary(fields: [String!], filterBySubjects: [String!]): JSON!
}

type CatalogueRecordConnection implements Connection {
  edges: [Edge!]!
  nodes: [Node!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CatalogueEdge implements Edge {
  cursor: String!
  node: Node!
}

type CatalogueRecord implements Node {
  id: ID!
  target: JSON!
}

# Browser events

type BrowserEvent implements Node {
  id: ID!
  name: String!
  createdAt: DateTime
  info: JSON!
}

input BrowserEventInput {
  name: String!
  createdAt: DateTime!
  info: JSON!
}

# GraphQL types

type Query {
  # Catalogue
  catalogue: Catalogue!

  # Client usage tracking
  browserEvents: [Node]!
}

type Subscription {
  onFilterChange: JSON
}

type Mutation {
  logBrowserEvents(input: [BrowserEventInput]!): [Boolean]!
}
