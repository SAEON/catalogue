# https://itnext.io/improve-your-graphql-schema-with-the-relay-specification-8952d06998eb

scalar DateTime
scalar JSON
scalar Void
scalar WKT_4326

type PageInfo {
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor: JSON
  endCursor: JSON
}

# Interfaces

interface Node {
  id: ID!
}

interface Connection {
  # A list of edges
  edges: [Edge!]!
  # A list of nodes
  nodes: [Node!]
  # Information to aid in pagination
  pageInfo: PageInfo!
  # Count of total results
  totalCount: Int!
}

interface Edge {
  cursor: String!
  node: Node!
}

# Client

type BrowserClient {
  # Save a web-browser's search context for retrieving
  persistSearchState(state: JSON!): ID!
  findSearchState(id: ID!): JSON
}

# Catalogue

input ES_Cursor {
  id: ID
  score: Float
}

input TermInput {
  field: String!
  value: String!
}

type Catalogue {
  id: ID!

  # Fetch metadata records from SAEON's data catalogue
  records(
    # Fetch a single record by SAEON IDs (other arguments are ignored)
    ids: [ID!]
    # Fetch a single record by DOIs (other arguments are ignored)
    dois: [String!]
    # Fulltext search for provided string
    match: String
    # Search for exact matches of field values (intersection)
    terms: [TermInput!]
    # Polygon specified as WKT and conforming to EPSG:4326. Coordinates are expected as (x, y)
    extent: WKT_4326
    # Page size (maximum allowed is 10 000 items per page)
    size: Int
    # Return elements in the list that come after the specified cursor
    after: ES_Cursor
    # Return elements in the list that come before the specified cursor
    before: ES_Cursor
  ): CatalogueConnection!

  # Get count aggregation of records by fields, with optional filters
  summary(
    filterByIds: [ID!]
    # Fetch a single record by DOIs (other arguments are ignored)
    filterByDois: [String!]
    # Filter on full text search
    filterByText: String
    # Polygon specified as WKT and conforming to EPSG:4326. Coordinates are expected as (x, y)
    filterByExtent: WKT_4326
    # List of terms to filter on
    filterByTerms: [TermInput!]
    # Provide IDs that should be filtered on
    # A list of fields to perform term agggregation on
    fields: [String!]
    limit: Int
  ): JSON!

  # Refreshes the Elasticsearch index from the source (currently the source is the old Elasticsearch instance)
  refreshIndex(authorizationCode: String!): JSON!
}

type CatalogueConnection implements Connection {
  edges: [CatalogueRecordEdge!]!
  nodes: [CatalogueRecord!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CatalogueRecordEdge implements Edge {
  cursor: String!
  node: CatalogueRecord!
}

type CatalogueRecord implements Node {
  id: ID!
  target: JSON!
  citation(style: CitationStyle, language: CitationLocale): String! # CitationStyle and CitationLocale are enums defined at runtime
}

# Browser events
type BrowserEvent implements Node {
  id: ID!
  type: String!
  createdAt: DateTime
  info: JSON!
  clientVersion: String!
  # Most recent source code commit of currently executing code
  commitHash: String!
}

input BrowserEventInput {
  type: String!
  createdAt: DateTime!
  info: JSON!
  clientVersion: String!
  # Most recent source code commit of currently executing code
  commitHash: String!
}

input FeedbackInput {
  text: String!
  rating: Int!
  pathname: String!
  # Most recent source code commit of currently executing code
  commitHash: String!
}

# GraphQL types

type Query {
  # Return the Catalogue entity with optional input for indicating source where the catalogue software was linked from
  catalogue(referrerId: String): Catalogue!
  # Return the BrowserClient entity
  browserClient: BrowserClient!
}

type Subscription {
  onFilterChange: JSON
}

type Mutation {
  logBrowserEvents(input: [BrowserEventInput]!): [Boolean]!
  submitFeedback(input: FeedbackInput!): Boolean!
  # Return the BrowserClient entity
  browserClient: BrowserClient!
}
