input ES_Cursor {
  id: ID
  score: Float
}

input TermInput {
  field: String!
  value: String!
}

type Catalogue {
  id: ID!

  # Fetch metadata records from SAEON's data catalogue
  records(
    # Fetch a single record by SAEON IDs (other arguments are ignored)
    ids: [ID!]
    # Fetch a single record by DOIs (other arguments are ignored)
    dois: [String!]
    # Fulltext search for provided string
    text: String
    # Search for exact matches of field values (intersection)
    terms: [TermInput!]
    # Polygon specified as WKT and conforming to EPSG:4326. Coordinates are expected as (x, y)
    extent: WKT_4326
    # Page size (maximum allowed is 10 000 items per page)
    size: Int
    # Return elements in the list that come after the specified cursor
    after: ES_Cursor
    # Return elements in the list that come before the specified cursor
    before: ES_Cursor
  ): CatalogueConnection!

  # Get count aggregation of records by fields, with optional filters
  summary(
    filterByIds: [ID!]
    # Fetch a single record by DOIs (other arguments are ignored)
    filterByDois: [String!]
    # Filter on full text search
    filterByText: String
    # Polygon specified as WKT and conforming to EPSG:4326. Coordinates are expected as (x, y)
    filterByExtent: WKT_4326
    # List of terms to filter on
    filterByTerms: [TermInput!]
    # Provide IDs that should be filtered on
    # A list of fields to perform term agggregation on
    fields: [String!]
    limit: Int
  ): JSON!
}

type CatalogueConnection implements Connection {
  edges: [CatalogueRecordEdge!]!
  nodes: [CatalogueRecord!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CatalogueRecordEdge implements Edge {
  cursor: String!
  node: CatalogueRecord!
}

type CatalogueRecord implements Node {
  id: ID!
  target: JSON!
  citation(style: CitationStyle, language: CitationLocale): String! # CitationStyle and CitationLocale are enums defined at runtime
}
