scalar DateTime
scalar JSON
scalar Email
scalar Void
scalar WKT_4326
scalar FunctionString

type PageInfo {
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor: JSON
  endCursor: JSON
}

# Interfaces

interface Node {
  id: ID!
}

interface Connection {
  """
  A list of edges
  """
  edges: [Edge!]!
  """
  A list of nodes
  """
  nodes: [Node!]
  """
  Information to aid in pagination
  """
  pageInfo: PageInfo!
  """
  Count of total results
  """
  totalCount: Int!
}

interface Edge {
  cursor: String!
  node: Node!
}

#  Types

type StatusHash {
  id: ID!
}

enum DateBucket {
  minute
  hour
  day
  month
  year
}

enum SortDirection {
  ASC
  DESC
}

enum DownloadsReportDimensions {
  doi
  clientSession
  clientIpAddress
  clientIpLocation
  clientUserAgent
  clientPathname
  referrer
  date
  count
}

input SortConfig {
  dimension: DownloadsReportDimensions
  direction: SortDirection
}

type DownloadSummary {
  """
  DOI of metadata record (or SAEON id if no DOI)
  """
  doi: ID!
  clientSession: String
  clientIpAddress: String
  """
  Resolve an IP Address to location using https://ip-api.com/
  """
  clientIpLocation: String
  clientUserAgent: String
  clientPathname: String
  referrer: String
  """
  Download date, rounded down to the hour
  """
  date(bucket: DateBucket): DateTime!
  count: Int!
}

enum ListType {
  curated
  public
}

type List {
  id: ID!
  search: JSON!
  title: String
  description: String
  referrer: String
  url: String
  createdBy: String
  disableSidebar: Boolean
  showSearchBar: Boolean
  type: ListType
}

type Metadata {
  id: ID!
  doi: ID
  sid: ID
  institution: String
  collection: String
  schema: String
  metadata: JSON
  validated: Boolean
  errors: JSON
  state: String
  title: String
}

type Query {
  """
  Fetch metadata from the ODP on behalf of user
  """
  metadata(offset: Int, limit: Int): [Metadata!]!
  """
  Search metadata from the ODP (indexed via Elasticsearch)
  """
  indexedMetadata(ids: [ID!]): [Metadata!]!
  """
  Fetch a list of Institutions as defined in the ODP
  """
  institutions: [String!]!
  """
  Fetch a list of possible schemas as defined in the ODP
  """
  schemas: [String!]!
  """
  Fetch a list of collections for a particular institution ad defined in the ODP
  """
  collections(institution: String!): JSON!
  """
  Return the Catalogue entity with optional input for indicating source where the catalogue software was linked from
  """
  catalogue(referrer: String): Catalogue!
  """
  Return a Dashboard entity
  """
  dashboard(id: ID!): Dashboard
  """
  Find a chart
  """
  charts(ids: [ID!]!): [Chart!]
  """
  Find a filter
  """
  filters(ids: [ID!]!): [Filter!]
  """
  Retrieve a web-browser's previously saved databook
  """
  databook(id: ID!): Databook
  """
  Retrieve search context (i.e. a dynamic list)
  """
  list(id: ID!): List
  """
  Retrieve many search contexts (i.e. many dynamic lists)
  """
  lists: [List!]!
  """
  Retrieve a web-browser's previously saved atlas TODO - should be on query
  """
  atlas(id: ID!): JSON
  """
  Retrieve dashboards by id
  """
  dashboards(ids: [ID!]!): [Dashboard!]
  downloadsReport(sort: SortConfig): [DownloadSummary]!
  roles: [Role]!
  permissions: [Permission]!
  users: [User]!
  user(id: ID!): User
}

input DataDownloadFormSubmission {
  """
  DOI (or ID if no DOI) of the metadataRecord related to the downloaded dataset
  """
  recordId: ID!
  emailAddress: Email
  organization: String
  comments: String
  allowContact: Boolean
}

input MetadataInput {
  collection_key: String!
  schema_key: String!
  metadata: JSON!
}

input UpdateMetadataInput {
  id: ID!
  sid: ID!
  doi: ID
  institution_key: String!
  metadataInput: MetadataInput
}

type Mutation {
  createMetadata(institution: String!, numberOfRecords: Int, input: MetadataInput!): [Metadata!]!
  updateMetadata(input: [UpdateMetadataInput!]!): [Metadata!]!
  updateRecordDataFormat(id: ID!, immutableResource: JSON!): Void
  submitDataDownloadForm(input: DataDownloadFormSubmission!): Void
  logBrowserEvents(input: [BrowserEventInput]!): Void
  """
  Save a web-browser's search context for retrieving as a databook
  """
  createDatabook(search: JSON!, createdBy: String!): ID!
  """
  Save a web-browser's search context for retrieving as an atlas
  """
  createAtlas(search: JSON!, createdBy: String!): ID!
  """
  Delete a saved list (only curated lists can be deleted)
  """
  deleteList(id: ID!): Boolean!
  """
  Save a search context (i.e. a dynamic list)
  """
  saveList(
    id: ID
    search: JSON!
    createdBy: String!
    type: ListType
    title: String
    description: String
  ): List!
  """
  Retrieve a web-browser's previously saved databook
  """
  databook(id: ID!): Databook
  createDashboard(title: String, subtitle: String, description: String, databookId: ID!): Dashboard!
  updateDashboard(
    id: ID!
    layout: JSON
    title: String
    subtitle: String
    description: String
    filters: [ID!]
  ): Dashboard!
  updateDatabook(id: ID!, editors: JSON): Databook!
  """
  Return a Dashboard entity
  """
  dashboard(id: ID!): Dashboard
  deleteDashboard(id: ID!): Boolean!
  createChart(
    title: String
    description: String
    databookId: ID!
    data: JSON!
    type: ChartType!
    config: JSON!
    sql: String!
  ): Chart!
  editChart(id: ID!, title: String, description: String, setOption: FunctionString): Chart!
  deleteChart(id: ID!): Boolean!
  createFilter(
    name: String
    databookId: ID!
    columnFiltered: String
    values: [String]
    sql: String
  ): Filter!
  deleteFilter(id: ID!): Boolean!
  assignRolesToUser(userId: ID!, roleIds: [ID!]!): User!
}

input BrowserEventInput {
  type: String!
  createdAt: DateTime!
  info: JSON!
  clientVersion: String!
  commitHash: String!
  referrer: String
}
